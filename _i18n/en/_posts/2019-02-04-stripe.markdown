---
layout: post
title:  Connecting a Rails application with Stripe
date:   2019-02-02 12:30:00 +0200
tags: rails stripe api
categories: tutorial
thumbnail: /img/blog/stripe.svg
comments: true
---

For my [iSignif](https://isignif.fr) project I wanted to implement **restricted access** functionality for **premium account**. The ultimate goal is for the user to subscribe to a premium account in order to access certain pages.

In order to implement this functionality, we first analyzed the need. The expected behaviour is as follows:

1. the customer benefits from one month of discovery of our tool as soon as he registers
2. once his _balance of premium days_ is exhausted, he receives an email indicating that he will have to buy back days
3. the user updates his balance by making a **on-time payment** which adds one month to his premium balance where he takes out a subscription which will make a **automatic payment** at the beginning of each month

In order to implement this, I quickly went through the existing payment solutions (PayPal, BNP, etc...). It turned out that [Stripe](https://stripe.com) was the best compromise.

![Stripe's logo](/img/blog/stripe.svg)

> Stripe is an American company that aims to simplify online payments. Created in 2010, Stripe now weighs more than 10 billion!

I chose Stripe because its advantages are:

- the customer can pay without having an account opened at Stripe
- the rates are quite "reasonable" _(1.4% + 0.25€ per transaction for European cards)_
- the ease of implementation because, in addition to offering a beautiful API, Stripe offers libraries for the most commonly used languages ([PHP](https://github.com/stripe/stripe-php), [Pyhton](https://github.com/stripe/stripe-python),[Ruby](https://github.com/stripe/stripe-ruby), [Java](https://github.com/stripe/stripe-java) and even [Go](https://github.com/stripe/stripe-go)
- an [excellent documentation](https://stripe.com/docs)

In addition, Stripe goes much further than a _simple_ payment solution since it offers a whole ecosystem to manage customers, invoices, products, etc....

In this article I will therefore retrace the development of the functionality by trying to be as generic as possible. I also specify before starting that it is not a sponsored item and I did not receive any money from Stripe (I would have liked...).

**TLDR**: Stripe is very simple to set up and really allows us to completely delegate payment management. This allows you to focus on your business and is invaluable for a project that is just beginning.  

## Table of content

* TOC
{:toc}

## Implementation of the premium mode

In this first part I will talk to you about the implementation of the _premium_ feature. Here we will just code the expected behavior without touching Stripe for the moment (be patient...).

### Modifying `User` model

We will therefore start setting up a system to restrict certain pages to _premium_ users.

L'idée est d'ajouter un attribut `premium_until` de type [`DateTime`](https://api.rubyonrails.org/classes/DateTime.html) qui contiendra la date de validité du compte premium. On ajoute donc cette colonne pour la table des `users`.

The idea is to add a `premium_until` [`DateTime`](https://api.rubyonrails.org/classes/DateTime.html) attribute which will contains  validity date of the premium account. So we add this column for the `users` table.

~~~bash
$ rails g migration add_premium_until_to_users premium_until:date
~~~

This command will generate this migration:

~~~ruby
# db/migrate/20190116132207_addpremiumuntil_to_users.rb
class AddPremiumUntilToUsers < ActiveRecord::Migration[5.2]
  def change
    add_column :users, :premium_until, :date
  end
end
~~~

Since we are generous we will also create an additional migration to **offer one month** to all existing users:

~~~bash
$ rails g migration offer_one_monthspremiumto_users
~~~

We're just looping through all the existing users

~~~ruby
# db/migrate/20190116132207_add_premium_until_to_users.rb
# ...
def up
  premium_until_offer = DateTime.now + 1.month
  User.all.each { |user| user.update! premium_until: premium_until_offer }
end
~~~

There you go.

### Creation of the premium logic

We now have a nice `premium_until` column who contains the **validity date** of the premium account. We want to **create** a `User#increment_premium` method who will be called when a payment is received. This one will simply add one month to the `premium_until` attribute.

Let's create the unit tests that define the expected behavior of this function. This method is **very important** so we will cover all possible cases:

- when the user already has a balance of days

~~~ruby
# test/models/user_test.rb
test 'should offer one month premium to user' do
  user = User.create!(
    premium_until: (Date.today + 5.days)
    # ...
  )

  assert_equal (Date.today + 1.month + 5.days), user.premium_until
end
~~~

- when the user does not yet have a day balance

~~~ruby
# test/models/user_test.rb
test 'should set correct premium_until for never premium user' do
  user = User.new
  user.increment_premium
  assert_equal (Date.today + 1.month), user.premium_until
end
~~~

- checks that we add one month from today for a user who has just reactivated his account after an inactivity

~~~ruby
# test/models/user_test.rb
test 'should set correct premium_until for past-premium user' do
  user = User.new(premium_until: (Date.today - 1.year))
  user.increment_premium
  assert_equal (Date.today + 1.month), user.premium_until
end
~~~

I think these tests are sufficient to cover all possible cases. We have written a lot of tests but the implementation is very short:

~~~ruby
# app/models/user.rb
class User < ApplicationRecord
  before_create :increment_premium

  def increment_premium
    if premium_until.nil? || (premium_until < Date.today)
      self.premium_until = Date.today
    end
    self.premium_until += 1.month
  end
  # ...
end
~~~

There you go. The tests are now passing:

~~~bash
$ bin/rails test test/models/user_test.rb
# Running:

....
~~~

### Restrictions actions

Implementing the restriction is really easy but let's start by writing the unit tests. We will therefore create two **fixtures** _(fixtures are data inserted in the database in order to test the application)_ one representing a premium user and another representing an expired user.

~~~yml
# test/fixtures/users.yml
premium_advocate:
  premium_until: <%= DateTime.now + 1.month %>
  # ...

expired_advocate:
  premium_until: <%= DateTime.now - 1.month %>
  # ...
~~~

Now let's imagine a page only authorized for premium users. The test is quite easy:

1. We connect a user
2. You can access the page
3. we check that the answer is 200 (= _success_) if the user is premium and otherwise we check that the user is redirected to the Stripe payment page

So here is the implementation of the tests:

~~~ruby
# test/controllers/acts_controller_test.rb
class ActsControllerTest < ActionDispatch::IntegrationTest

  test 'should forbid get index for non-premium user' do
    login users(:expired_advocate)
    get acts_url
    assert_response root_path
  end

  test 'should get index for premium user' do
    login users(:premium_advocate)
    get acts_url
    assert_response :success
  end
  # ...
end
~~~

If you run the tests at this point you will get a pretty mistake like that:

~~~
ActsControllerTest#test_should_forbid_get_index_for_non-premium_user
Expected response to be a <3XX: redirect>, but was a <200: OK>
~~~

Implementation to get it through is quite easy. Simply create a method that will verify that the `premium_until` attribute of the connected user is greater than `DateTime.now`. Then simply call this method using a [controler _hook_](https://api.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-before_action). The is the code:

~~~ruby
# app/controllers/acts_controller.rb
class ActsController < ApplicationController
  before_action :redirect_if_not_premium, only: %i[index]
  # ...

  private

  def redirect_if_not_premium
    redirect_to root_path if current_user.nil? or current_user.premium_until < DateTime.now
  end
end
~~~

> The `current_user` method allows me to retrieve the user connected to the application. To implement it, I recommend that you use [Authlogic](https://github.com/binarylogic/authlogic)

There you go. The test should now pass! The creation of the logic for the user mode is now complete. Let's move on (finally) to Stripe!

## Punctual payment

We set up logic to restrict some pages to premium users. We also created the method who will add one month of premium account to a user. All that remains is to call this method when a payment is made.

First of all, to use Stripe, you need to create an account that will allow you to get an *API key*. Once this is done, integration into your Rails application is pretty easy thnaks to [Stripe's gem](https://github.com/stripe/stripe-ruby/)! Of course we'll use it here.

So let's start by adding this gem to our project:

~~~bash
$ bundle add stripe
~~~

In this first version we will simply set up a Stripe punctual payment and call `User#increment_premium` if everything goes well. In Stripe terms, a simple payment is a _charge_.

So we will create a `charges` controller that will contain two actions:

- `new` which will simply propose a form to pay
- `create` who will receive Stripe's answer

So let's generate all this with `rails generate` command :

~~~bash
$ rails generate controller charges new create
~~~

All we have to do now is modify the code generated by Rails. First of all, we modify routes:

~~~ruby
# config/routes.rb
Rails.application.routes.draw do
  # ...
  resources :charges, only: %i[new create]
  # ...
end
~~~

The actions are then implemented in the controller:

~~~ruby
# app/controllers/charges_controller.rb
class ChargesController < ApplicationController
  # display Stripe form to make a new payment
  def new; end

  #  & check all data from Sripe
  def create
    # Amount in cents
    @amount = 500

    # get customer from POST params
    customer = Stripe::Customer.create(
      email: params[:stripeEmail],
      source: params[:stripeToken]
    )

    begin
      charge = Stripe::Charge.create(
        customer: customer.id,
        amount: @amount,
        description: 'Rails Stripe customer',
        currency: 'eur'
      )
      current_user.increment_premium!
    rescue Stripe::CardError => e
      flash[:error] = e.message
      redirect_to new_charge_path
    end
  end
end
~~~

That's represent a lot of code. Let me take a look at `create` method:

1. `Stripe::Customer.create` will register the user on Stripe. Stripe will take care of all the checks for us (card validity, information transmitted, etc...)
2. `Stripe::Charge.create` will create the _charge_ and linking it to the _customer_ we just created
3. We call the `increment_premium` method to add credit to the user

It is Look very easy. Now, we modify the views a little bit and generate a form:

~~~erb
<!-- app/views/charges/new.html.erb -->
<h1>Souscrire à un abonnement mensuel</h1>
<p>Actuellement, votre compte premium est disponible jusqu'au <%= current_user.premium_until.strftime('%d/%m/%Y') %></p>
<%= form_tag charges_path do %>
  <script src="https://checkout.stripe.com/checkout.js" class="stripe-button"
          data-key="<%= Rails.application.secrets.stripe[:publishable_key] %>"
          data-description="A month's subscription"
          data-amount="500"
          data-locale="auto"></script>
<% end %>
~~~

~~~erb
<!-- app/views/charges/create.html.erb -->
<h1>Votre paiement a été accepté</h1>
<p>Le paiement a été effectué. Votre compte premium à été étendu au <%= current_user.premium_until.strftime('%d/%m/%Y') %></p>
~~~

We end with configuration. Simply retrieve the API keys via the Stripe interface and add them to the `secrets.yml` file.

~~~yaml
# config/secrets.yml
development:
  stripe:
    publishable_key: pk_test_azerty
    secret_key: sk_test_clef_a_ne_pas_commiter

test: &development

production:
  stripe:
    publishable_key: pk_live_azerty
    secret_key: sk_live_clef_a_ne_pas_commiter
~~~

> Of course you must enter *your* own* key here

And now to create the necessary configuration in a Stripe-specific _initializer_:

~~~ruby
# config/initializers/stripe.rb
Rails.configuration.stripe = {
  publishable_key: Rails.application.secrets.stripe[:publishable_key],
  secret_key: Rails.application.secrets.stripe[:secret_key]
}

Stripe.api_key = Rails.application.secrets.stripe[:secret_key]
~~~

Once the first version is implemented, it is enough to test that everything is going well.

> At the risk of disappointing you, I didn't invent anything and I almost pumped it all out of [Stripe's guide](https://stripe.com/docs/checkout/rails).

To test, launch the Rails server and connect to <http://localhost:3000/charges/new>. A button will take you to Stripe's form:

![Formulaire de paiement de Stripe](/img/blog/stripe_first_form.png)

I have voluntarily used the card number `4242 4242 4242 4242 4242 4242` which is a test card. Some credits cards numbers allow you to simulate errors. The complete list of test cards is available [here](https://stripe.com/docs/testing#cards)

Once the form has been sent, you are redirected to the `charges#create` page which confirms your purchase. You can find the payment on Stripe in the section _payments_:

![Formulaire de paiement de Stripe](/img/blog/stripe_first_payment.png)

### Backup of the _cutomer token_

Nous allons effectuer une petite modification à l'implémentation proposée par Stripe. Nous voulons sauvegarder le _customer_ créé par Stripe afin de le réutiliser s'il paie une nouvelle fois. On va donc ajouter une colonne `users.stripe_token`.

~~~
$ rails g migration add_stripe_token_to_users stripe_token:string
~~~

Nous allons créer un _concern_ qui va s'occuper de récupérer ou créer un _customer_ Stripe:

> Si vous n'êtes pas à l'aise avec les _concerns_, j'en parle dans un [précédent article](http://rousseau-alexandre.fr/tutorial/2018/12/03/zip-active-storage.html#factorisation).

~~~ruby
# app/controllers/concerns/stripe_concern.rb
module StripeConcern
  extend ActiveSupport::Concern

  protected

  # Try to retreive Stripe customer and create if not already registered
  # @params [User]
  # @return [Stripe::Customer]
  def create_or_retrieve_customer(user)
    customer = retrieve_stripe_customer(user)

    if customer.nil?
      customer = Stripe::Customer.create email: params[:stripeEmail], source: params[:stripeToken]
      user.update! stripe_token: customer.id
    end

    customer
  end

  private

  # @params [User]
  # @return [Stripe::Customer|Nil]
  def retrieve_stripe_customer(user)
    return nil if user.stripe_token.nil?

    begin
      customer = Stripe::Customer.retrieve user.stripe_token
      return customer
    rescue Stripe::InvalidRequestError
      # if stripe token is invalid, remove it!
      user.update! stripe_token: nil
      return nil
    end
  end
end
~~~

Il suffit maintenant de modifier un peu notre contrôleur pour l'utiliser.

~~~ruby
# app/controllers/charges_controller.rb
class ChargesController < ApplicationController
  include StripeConcern
  # ...

  def create
    # Amount in cents
    @amount = 500

    customer = create_or_retrieve_customer(current_user)

    begin
      charge = Stripe::Charge.create(
        customer: customer.id,
        amount: @amount,
        description: 'Rails Stripe customer',
        currency: 'eur'
      )
      current_user.increment_premium!
    rescue Stripe::CardError => e
      flash[:error] = e.message
      redirect_to new_charge_path
    end
  end
end
~~~

Et voilà! Le fonctionnement est identique mais désormais nous récupérons le client s'il existe déjà. Nous pouvons aussi nous passer du bouton Stripe si l'utilisateur a déjà un token:

~~~erb
<!-- app/views/charges/new.html.erb -->
<h1>Souscrire à un abonnement mensuel</h1>
<p>Actuellement, votre compte premium est disponible jusqu'au <%= current_user.premium_until.strftime('%d/%m/%Y') %></p>
<%= form_tag charges_path do %>
  <% if current_user.stripe_token %>
    <%= submit_tag 'Payer avec votre compte Stripe' %>
  <% else %>
    <script src="https://checkout.stripe.com/checkout.js" class="stripe-button"
            data-key="<%= Rails.application.secrets.stripe[:publishable_key] %>"
            data-description="A month's subscription"
            data-amount="500"
            data-locale="auto"></script>
  <% end %>
<% end %>
~~~

## Abonnement

Ne lâchez pas, nous avons presque terminé. Une des dernière fonctionnalité à créer est de proposer un abonnement. L'utilisateur pourra ainsi souscrire un abonnement qui enclenchera un paiement automatique au début du mois. Dans le jargon de Stripe, cela s'appelle une [*subscriptions*](https://stripe.com/docs/billing/subscriptions/products-and-plans).

> Chaque plan est joint à un produit qui représente (...) le service offert aux clients. Les produits peuvent avoir plus d'un plan, reflétant les variations de prix et de durée - comme les prix mensuels et annuels à des taux différents. Il existe deux types de produits: les biens et les services. (...) qui sont destinés aux abonnements.

### Création du plan

Créons donc notre premier produit [la](https://stripe.com/docs/api/plans/create?lang=ruby) en utilisant [la gemme Stripe](https://github.com/stripe/stripe-ruby/). Voici un exemple avec la console Rails (Vous pouvez faire la même chose en utilisant l'interface d'administration).

~~~ruby
2.6.0 :001 > product= Stripe::Product.create name: 'Abonnement compte premium', type: 'service'
 => #<Stripe::Product:0x3fe4f20a1420 id=prod_EMb13PJreiAcF2> JSON: {
2.6.0 :002 > plan = Stripe::Plan.create amount: 5000, interval: 'month', product: product.id, currency: 'eur', id: 'premium-monthly'
 )
  => #<Stripe::Plan:0x2ab3e0b46d24 id=premium-monthly> JSON: {
~~~

> Là encore je n'ai rien inventé, tout est [Dans la documentation de Stripe](https://stripe.com/docs/api/subscriptions/object?lang=ruby)


Nous obtenons donc un belle instance Ruby correspondant à un _Plan_. Nous allons juste noter l' `id` et le noter dans le fichier `secret.yml`:

~~~yaml
# config/secrets.yml
development:
  stripe:
    premium_plan_id: premium-monthly
    # ...
~~~

### Création de la logique

Comme nous avons créé un contrôleur `charges`, nous allons en créer un nouveau nommé `subscriptions` avec deux méthodes:

- `new` qui va simplement proposer un formulaire pour payer
- `create` qui recevra la réponse de Stripe

Utilisons une fois de plus la commande `rails generate`

~~~bash
$ rails generate controller subscriptions new create
~~~

Cette méthode n'est pas parfaite, il faut modifier un peu les routes

~~~ruby
# config/routes.rb
Rails.application.routes.draw do
  resources :subscriptions, only: %w[new create]
  # ...
end
~~~

L'implémentation du `SubscriptionsController` est quasiment identique au `ChargesController` (c'est pour cela que nous avons utilisé un _concern_ un peu plus haut afin d'éviter de dupliquer le code). Nous devons juste appeler la méthode `Stripe::Charge.create`

~~~ruby
class SubscriptionsController < ApplicationController
  include StripeConcern

  before_action :check_login
  before_action :only_advocates

  def new; end

  def create
    customer = create_or_retrieve_customer(current_user)

    begin
      Stripe::Subscription.create(customer: customer.id, items: [{ plan: Rails.application.secrets.stripe[:premium_plan_id] }])
    rescue Stripe::CardError => e
      flash[:error] = e.message
      redirect_to new_subscription_path
    end
  end
end
~~~

Et les vues:

~~~erb
<!-- app/views/subscriptions/new.html.erb -->
<h1>Souscrire à un abonnement mensuel</h1>
<p>Abonner vous afin de recharger votre compte automatiquement tous les mois</p>
<%= form_tag subscriptions_path do %>
  <% if current_user.stripe_token %>
    <p class="text-center">
      <%= submit_tag t('premium.pay'), class: 'btn btn-primary btn-lg' %>
    </p>
  <% else %>
    <script src="https://checkout.stripe.com/checkout.js" class="stripe-button"
        data-key="<%= Rails.application.secrets.stripe[:publishable_key] %>"
        data-image="<%= image_url 'favicon.png' %>"
        data-name="iSignif SAS"
        data-description="Compte premium pendant un mois"
        data-email="<%= current_user.email %>"
        data-locale="auto"></script>
  <% end %>
<% end %>
~~~

~~~erb
<!-- app/views/subscriptions/create.html.erb -->
<h1><%= @title %></h1>
<p>Le prélèvement automatique est maitenant configuré</p>
~~~

Et voilà. Nous pouvons désormais souscrire un abonnement.

### Mise en place du _Webhook_

Nous avons mis en place un paiement mensuel mais nous voulons être notifié des paiements effectués au début du mois. Dans notre cas, le _workflow_ type est le suivant:

1. l’utilisateur effectue une demande d'abonnement
2. Stripe crée un abonnement pour cette utilisateur
3. lorsque l'abonnement est renouvelé (c-à-d. lorsque Stripe facture le client et qu'il est facturé de nouveau).

Stripe envoie une requête pour signaler que le paiement a été effectué par le biais du _hook_. Les  *Webhook* sont simplement des routes que nous mettons à disposition pour recevoir les requêtes de la part de Stripe. Une fois la route créée, nous devons communiquer l'URL à Stripe via l'interface d'administration de Stripe (cela se fait très facilement).

![Formulaire de création d'un Webhook](/img/blog/stripe_webhook.png)

> Notez que j'ai choisi de ne recevoir que le signal `invoice.payment_succeeded` qui est envoyé lorsqu'une facture est payée. Encore une fois je n'invente rien, tout est [dans la documentation de Stripe](https://stripe.com/docs/billing/webhooks#tracking)

Générons une route avec Rails.

~~~bash
$ rails g controller  hooks stripe --no-assets --no-helper
~~~

Nous allons juste supprimer la vue que Rails vient de nous créer et passer la route accessible avec le verbe `POST`:

~~~bash
$ rm -r app/views/hooks
~~~

~~~ruby
# config/routes.rb
Rails.application.routes.draw do
  post 'hooks/stripe'
  # ...
end
~~~

Il suffit maintenant d'ajouter une méthode dans le contrôleur qui recevra  la requête de Stripe.Comme d'habitude, commençons par les tests.

### Test fonctionnels

C'est toujours compliqué de tester l'intégration d'un API donc j'ai simplement choisi de simuler une requête de la part de Stripe et de vérifier si notre contrôleur ajoute du crédit à l'utilisateur.

pour cela,  j'ai simplement copié/collé les paramètres envoyés par Stripe via leur [interface de test des webhooks](https://dashboard.stripe.com/test/webhooks/).

![Test d'envoie d'un Webhook via l'administration](/img/blog/stripe_webook_request.png)

Une fois la requête copiée, je l'ai transformée en `Hash` Ruby en ne gardant que les paramètres qui m'intéressent.

~~~ruby
# test/controllers/hooks_controller_test.rb
# ...
class HooksControllerTest < ActionDispatch::IntegrationTest
  # Stripe webook params copied from <https://dashboard.stripe.com/test/webhooks>
  STRIPE_INVOICE_SUCCEEDED_PARAMS = {
    id: 'invoice.payment_00000000000000',
    type: 'invoice.payment_succeeded',
    # ...
    data: {
      object: {
        customer: 'cus_00000000000000',
        # ...
      }
    },
    # ...
  }.freeze

  # ...
end
~~~

Maintenant il suffit d'envoyer une requête `POST` et de vérifier que notre utilisateur est incrémenté.

~~~ruby
# test/controllers/hooks_controller_test.rb
# ...
class HooksControllerTest < ActionDispatch::IntegrationTest
  # ...

  setup do
    @user = users(:one_advocate)
  end

  test 'Stripe hook should add premium days to the given user' do
    old = user.premium_until
    post hooks_stripe_url, params: STRIPE_INVOICE_SUCCEEDED_PARAMS
    assert_response :success
    user.reload
    assert_operator old, :<=, user.premium_until
  end
end
~~~

Et voilà. L'implémentation est très simple:

~~~ruby
# app/controllers/hooks_controller.rb

class HooksController < ApplicationController
  protect_from_forgery except: [:stripe]

  def stripe
    if is_payment_succeeded?
      advocate = retrieve_user

      advocate.increment_premium! unless advocate.nil?
    end

    head :ok, content_type: 'text/html'
  end

  private

  def retrieve_user
    customer_token = params.dig(:data, :object, :customer)
    return nil if customer_token.nil?

    User.where(stripe_token: customer_token).first
  end

  def is_payment_succeeded?
    params[:type] == 'invoice.payment_succeeded'
  end
end
~~~

> Attention à bien désactiver le `protect_from_forgery` qui va bloquer les requêtes provenant de l'extérieur.

Et voilà, notre paiement récurrent est désormais en place!

### Test en développement

Il suffit d'utiliser un service comme [Ngrok](https://ngrok.com/) ou [Serveo](https://serveo.net/) (je vous recommande ce dernier qui est plus facile à utiliser) afin d'exposer votre application à l’extérieur et ensuite de tester votre _webhook_ via [l'interface de test des webhooks de Stripe](https://dashboard.stripe.com/test/webhooks/). Je ne vais pas vous le montrer ici car nous avons déjà mis en place un test qui le simule pour nous.

## Conclusion

Je vous ai donc démontré via cet article qu'il était très facile de mettre en place un système de paiement récurrent avec Stripe. La documentation quasi parfaite et leur gemme nous simplifient vraiment la tâche.

Mais les fonctionnalités de Stripe ne s'arrêtent pas la. Stripe nous permet aussi de mettre en place un système de facturation (avec la génération de belles factures PDF), de remboursement ou encore de gestion de litiges.

Je pense que pour la création de votre application il est beaucoup plus intelligent de déléguer toutes les tâches de paiement à Stripe et de se concentrer sur son business.
